#include <stdio.h>#include <string.h>#include <stdlib.h>/////////////////////////////第一道题：解字符串//////////////////////////////////////////void outputstr(const char* str){	int len = (int)strlen(str);	char* substr1 = new char[len + 1];	char* substr2 = new char[len + 1];	int sign1 = 0, sign2 = -1, sign3 = -1;	printf("%s -> ", str);	for (int i = 0; i < len; i++)	{		if (str[i] == '=')		{			sign2 = i;		}		if (str[i] == '&')		{			sign3 = i;			bool substr1valid = false;			if (sign2 - sign1 > 0)			{				memcpy(substr1, str + sign1, sign2 - sign1);				substr1[sign2 - sign1] = '\0';				substr1valid = true;			}			bool substr2valid = false;			if (sign3 - sign2 - 1 > 0)			{				memcpy(substr2, str + sign2 + 1, sign3 - sign2 - 1);				substr2[sign3 - sign2 - 1] = '\0';				substr2valid = true;			}			if (substr1valid && substr2valid)			{				printf("map[%s]=%s,", substr1, substr2);			}			sign1 = sign2 = sign3 = i + 1;		}	}	delete[] substr1;	delete[] substr2;	printf("\n");}/////////////////////////////第二道题：查找自串////////////////////////////////////////////算法一：暴力匹配算法 O(mn)int getsubstrpos(char* str1, char* str2){	int idx = 0;	int len1 = (int)strlen(str1);	int len2 = (int)strlen(str2);	if (len1 < len2)	{		return -1;	}	// 每次移动一个字符	while (true)	{		int pos = -1;		for (int i = 0; i < len2; i++)		{			if (str1[idx + i] != str2[i])			{				pos = i;				break;			}		}		if (pos == -1)		{			break;		}		idx++;		// 若 idx 已经超出母串长度，说明母串不包含该子串		if (idx >= len1)			return -1;	}	// 返回子串第一个字符在母串中的位置	return idx;}//算法二：kmp算法 O(m + n)void getnext(int next[], const char* str) // 获取每个字符部分匹配值{	next[0] = -1;	int len = strlen(str);	for (int i = 1; i < len; i++) 	{		int j = next[i - 1];		while (j >= 0 && str[i - 1] != str[j]) 			j = next[j];//递推计算		if (j >= 0 && str[i - 1] == str[j]) 			next[i] = j + 1;		else 			next[i] = 0;	}}int KMPgetsubstrpos(char* str1, char* str2){	int idx = 0;	int len1 = (int)strlen(str1);	int len2 = (int)strlen(str2);	if (len1 < len2)	{		return -1;	}	int* next = new int[len2];	getnext(next, str2);	// 每次移动一个字符	while (true)	{		int pos = -1;		for (int i = 0; i < len2; i++)		{			if (str1[idx + i] != str2[i])			{				pos = i;				break;			}		}		if (pos == -1)		{			break;		}		int add = (pos == 0 ? 1 : pos) - (pos == 0 ? 0 : next[pos]);		printf("已经匹配值=%d,部分匹配值=%d,增量=%d\n", pos, next[pos], add);		idx += add;		//idx += pos == 0 ? 1 : next[pos /*- 1*/] + 1;		// 若 idx 已经超出母串长度，说明母串不包含该子串		if (idx >= len1)			return -1;	}	delete[] next;	// 返回子串第一个字符在母串中的位置	return idx;}///////////////////////////////////////第三道题：链表逆转////////////////////////////////////////////struct LT{	int val;	LT* next;	LT()	{		val = 0;		next = nullptr;	}};struct LT* reserve(struct LT* head){	struct LT* p1 = nullptr, * p2 = nullptr, * p3 = nullptr;	p1 = head;	p2 = p1->next;	while (p2)	{		p3 = p2->next;		p2->next = p1;		p1 = p2;		p2 = p3;	}	head->next = NULL;	head = p1;	return head;}///////////////////////////////////////////////////////////////////////////////////int main(){	// 第一道题目测试	printf("====第一道题目测试===\n");	outputstr("a=b&c=d&");	outputstr("&&&===&a=b&");	outputstr("&&==&===&a=b&&cc=bb");	outputstr("&&==&===&au==b&&cc=bb&");	outputstr("&dsf==4444&ayy=buuu& dd=xiao dsdsd&");	// 第二道题目测试	printf("\n====第二道题目测试===\n");	char str1[64] = "BBCABCDABABCDABCDABDE";//"abceccesdceesttedd dsewf eh"; //"BBC ABCDAB ABCDABCDABDE";	char str2[64] = "ABAB";//"sdce";//"ABCDABD";//	printf("母字符串：%s，子字符串：%s\n", str1, str2);	printf("暴力匹配算法O(mn)：位置=%d\n", getsubstrpos(str1, str2));	printf("KMP算法匹配过程：\n");	printf("KMP算法O(m+n)：位置=%d\n", KMPgetsubstrpos(str1, str2));	// 第三道题目测试	printf("\n====第三道题目测试===\n");	LT lt1, lt2, lt3, lt4;	lt1.val = 1;	lt2.val = 2;	lt3.val = 3;	lt4.val = 4;	lt1.next = &lt2;	lt2.next = &lt3;	lt3.next = &lt4;	LT* p = &lt1;	printf("原链表：\n");	while (p != nullptr)	{		printf("%d\n", p->val);		p = p->next;	}	p = reserve(&lt1);	printf("逆转之后的链表：\n");	while (p != nullptr)	{		printf("%d\n", p->val);		p = p->next;	}	return 0;}